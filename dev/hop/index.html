<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>HopTB · HopTB.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">HopTB.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../abinitio_tutorial/">Ab initio calculation</a></li><li><a class="tocitem" href="../model_tutorial/">Model calculation</a></li><li><span class="tocitem">Features and API references</span><ul><li class="is-active"><a class="tocitem" href>HopTB</a><ul class="internal"><li><a class="tocitem" href="#Exported-functions"><span>Exported functions</span></a></li><li><a class="tocitem" href="#Documented-functions"><span>Documented functions</span></a></li></ul></li><li><a class="tocitem" href="../optics/">Optics</a></li><li><a class="tocitem" href="../hall/">Hall effects</a></li><li><a class="tocitem" href="../magnetism/">Magnetism</a></li><li><a class="tocitem" href="../bs/">Band Structure</a></li><li><a class="tocitem" href="../topology/">Topology</a></li><li><a class="tocitem" href="../group/">Symmetrization of TB model</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Features and API references</a></li><li class="is-active"><a href>HopTB</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>HopTB</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/HopTB/HopTB.jl/blob/main/docs/src/hop.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="HopTB"><a class="docs-heading-anchor" href="#HopTB">HopTB</a><a id="HopTB-1"></a><a class="docs-heading-anchor-permalink" href="#HopTB" title="Permalink"></a></h1><h2 id="Exported-functions"><a class="docs-heading-anchor" href="#Exported-functions">Exported functions</a><a id="Exported-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Exported-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="HopTB.TBModel" href="#HopTB.TBModel"><code>HopTB.TBModel</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>TBModel{T&lt;Number}</code> is a data type representing tight binding models.</p><p><strong>Fields</strong></p><ul><li><code>norbits::Int64</code>: number of orbits in the model</li><li><code>lat::SMatrix{3,3,Float64,9}</code>: primitive lattice vectors stored in columns</li><li><code>rlat::SMatrix{3,3,Float64,9}</code>: primitive reciprocal lattice vectors stored in columns</li><li><code>hoppings::Dict{SVector{3,Int16},Matrix{T}}</code>: R -&gt; ⟨0n|H|Rm⟩, where n is the first index and m is the second index.</li><li><code>overlaps::Dict{SVector{3,Int16},Matrix{T}}</code>: R -&gt; ⟨0n|Rm⟩</li><li><code>positions::Dict{SVector{3,Int16},SVector{3,Matrix{T}}}</code>: R -&gt; [⟨0n|rx|Rm⟩, ⟨0n|ry|Rm⟩, ⟨0n|rz|Rm⟩]</li><li><code>isorthogonal</code>: whether the different orbitals of the model is orthogonal to each other.</li><li><code>nsites::Union{Missing,Int16}</code>: It is possible that the orbitals can be grouped into several sites. Every group of orbitals should share the same position within the group, stored in <code>site_positions</code>.</li><li><code>site_norbits::Union{Missing,Vector{Int64}}</code>: number of orbitals for each site.</li><li><code>site_positions::Union{Missing,Matrix{Float64}}</code>: position of sites stored in column</li><li><code>orbital_types::Union{Missing,Vector{Vector{Int16}}}</code>: It is possible that the orbitals have definite symmetry representations. Example: <code>orbital_types = [[0], [0, 1]]</code> denotes that there are two sites, the first of which has 1 s orbital and the second of which has 1 s orbital and 1 p orbital (4 orbitals in total not counting spin). The orbitals of the TBModel should appear in a consistent order denoted by <code>orbital_types</code>.</li><li><code>isspinful::Union{Missing,Bool}</code>: If a TBModel is spinful, the first half of the orbitals should be spin up and the second half should be spin down. The two halves of the orbitals should be in one-to-one correspondence.</li><li><code>is_canonical_ordered::Union{Missing,Bool}</code>: If the orbital types are know, and <code>is_canonical_ordered</code> is true, then the orbitals are guaranteed to appear in a canonical order defined by decreasing Lz value. For example, canonical order of p orbitals should -px-i<em>py, pz, px-i</em>py. See the wikipedia for other orbitals.</li></ul><p><strong>Missing data</strong></p><p>Not all fields of TBModels are required to have a valid value. For example, it is possible the site information is missing for some models. Here are some rules:</p><ul><li><code>nsites</code>, <code>site_norbits</code>, <code>site_positions</code> should all either be missing or valid.</li><li><code>orbital_types</code> can only be valid if <code>nsites</code>, <code>site_norbits</code> and <code>site_positions</code> are valid.</li><li><code>is_canonical_ordered</code> can only be valid if <code>orbital_types</code> is valid.</li></ul><p><strong>Consistency check</strong></p><p>Any functions that directly modifies a TBModel should always maintain the following consistencies (if relevant fields are not missing):</p><ul><li><code>hoppings</code>, <code>overlaps</code> and <code>positions</code> matrices should always be Hermitian.</li><li><code>overlap[[0, 0, 0]]</code> should always be positive definite.</li><li><code>diag(position[[0, 0, 0]][α])/diag(overlap[[0, 0, 0]])</code> should be consistent with <code>site_positions</code>.</li><li>number of orbits should be consistent.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HopTB/HopTB.jl/blob/4dd0be7fb9f1f1b27dd50db5e4841284e56db10a/src/model.jl#L21-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HopTB.SharedTBModel" href="#HopTB.SharedTBModel"><code>HopTB.SharedTBModel</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>SharedTBModel</code> is a data type that encodes all the information of a <code>TBModel</code> into several SharedArrays.</p><p><code>SharedTBModel</code> is generally more efficient than <code>TBModel</code>. A typical workflow is to construct <code>TBModel</code> and then convert it into a <code>SharedTBModel</code> for large scale calculations.</p><p><strong>Fields</strong></p><ul><li><code>norbits::Int64</code>: number of orbits</li><li><code>isorthogonal::Bool</code>: whether orbits of the model are orthonormal</li><li><code>lat::SMatrix{3,3,Float64,9}</code>: primitive lattice vectors stored in columns</li><li><code>rlat::SMatrix{3,3,Float64,9}</code>: primitive reciprocal lattice vectors stored in columns</li><li><code>Rs::Matrix{Int16}</code>: R vectors stored in columns for hopping, overlap and position matrices. The number of R vectors is odd. The first R vector is [0, 0, 0]. For the rest of the matrix <code>Rs[:, 2:end]</code>, the first half and the second half is guaranteed to be in one-to-one correspondence R &lt;-&gt; -R.</li><li><code>Rcs::Matrix{Float64}</code>: R vectors in Cartesian coordinates.</li><li><code>H::SharedArray{T,2}</code>: <code>H = reshape(Hmatrix, (norbits * norbits, :))</code>. <code>Hmatrix[:, :, iR]</code> is ⟨0n|H|Rm⟩ where R is <code>Rs[:, iR]</code>. Since Hamiltonian is Hermitian, only first half R vectors in <code>Rs</code> are stored. In addition, <code>Hmatrix[:, :, 1]</code> is different: <code>Hmatrix[:, :, 1]</code> is ⟨0n|H|0m⟩/2.</li><li><code>S::Union{Nothing,SharedArray{T,3}}</code>: <code>S = reshape(Smatrix, (norbits * norbits, :))</code>. <code>Smatrix[:, :, iR]</code> is ⟨0n|Rm⟩ where R is <code>Rs[:, iR]</code>. Since overlap matrix is Hermitian, only first half R vectors in <code>Rs</code> are stored. In addition, <code>Smatrix[:, :, 1]</code> is different: <code>Smatrix[:, :, 1]</code> is ⟨0n|0m⟩/2. </li><li><code>r:SVector{3,SharedArray{T,2}}</code>: <code>S[α] = reshape(Smatrices[α], (norbits * norbits, :))</code>. <code>Smatrices[α][:, :, iR]</code> is ⟨0n|rα|Rm⟩ where R is <code>Rs[:, iR]</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HopTB/HopTB.jl/blob/4dd0be7fb9f1f1b27dd50db5e4841284e56db10a/src/model.jl#L89-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HopTB.sethopping!" href="#HopTB.sethopping!"><code>HopTB.sethopping!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sethopping!(ftm::FTBModel, R::AbstractVector{Int64}, n::Int64, m::Int64,
    p::Int64, hopping::Number)</code></pre><p>Set ⟨⟨0; n e^{-ilΩt}|H(t)|R; m e^{-i(l-p)Ωt}⟩⟩ to <code>hopping</code> for all l. Alternatively, <code>hopping</code> is ⟨n|H(p)|m⟩, where H(t) = ∑H(p)e^{-ipΩt}.</p><p>The Floquet Hamiltonian H<em>F=H-i∂t, in the basis functions |n⟩e^{-ilΩt}, is (H</em>F)<em>{l, l-p}=⟨⟨0; n e^{-ilΩt}|H(t)|R; m e^{-i(l-p)Ωt}⟩⟩-δ</em>{p,0}lΩ. This function automatically handles the above δ function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HopTB/HopTB.jl/blob/4dd0be7fb9f1f1b27dd50db5e4841284e56db10a/src/floquet.jl#L40-L52">source</a></section><section><div><pre><code class="language-julia hljs">sethopping!(tm::TBModel{T}, R::AbstractVector{&lt;:Integer}, n::Int64, m::Int64,
    hopping::Number) where T</code></pre><p>Set ⟨0n|H|Rm⟩ to <code>hopping</code> for <code>tm</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HopTB/HopTB.jl/blob/4dd0be7fb9f1f1b27dd50db5e4841284e56db10a/src/model.jl#L400-L407">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HopTB.addhopping!" href="#HopTB.addhopping!"><code>HopTB.addhopping!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">addhopping!(ftm::FTBModel, R::AbstractVector{Int64}, n::Int64, m::Int64,
    p::Int64, hopping::Number)</code></pre><p>Add <code>hopping</code> to ⟨⟨0; n e^{-ilΩt}|H(t)|R; m e^{-i(l-p)Ωt}⟩⟩.</p><p>This function does not add the onsite energy due to periodic driving.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HopTB/HopTB.jl/blob/4dd0be7fb9f1f1b27dd50db5e4841284e56db10a/src/floquet.jl#L66-L75">source</a></section><section><div><pre><code class="language-julia hljs">addhopping!(tm::TBModel, R::AbstractVector{&lt;:Integer}, hopping::Matrix{&lt;:Number})</code></pre><p>Add <code>hopping</code> to the Hamiltonian of <code>tm</code>.</p><p><code>hopping</code> should be a <code>(tm.norbits, tm.norbits)</code> array containing the matrix ⟨0n|H|Rm⟩ with n and m indices. If R is [0, 0, 0], then <code>hopping</code> needs to be Hermitian.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HopTB/HopTB.jl/blob/4dd0be7fb9f1f1b27dd50db5e4841284e56db10a/src/model.jl#L507-L517">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HopTB.setoverlap!" href="#HopTB.setoverlap!"><code>HopTB.setoverlap!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">setoverlap!(tm::TBModel{T}, R::AbstractVector{&lt;:Integer}, n::Int64, m::Int64,
    overlap::Number) where T</code></pre><p>Set ⟨0n|Rm⟩ to <code>overlap</code> for <code>tm</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HopTB/HopTB.jl/blob/4dd0be7fb9f1f1b27dd50db5e4841284e56db10a/src/model.jl#L551-L558">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HopTB.setposition!" href="#HopTB.setposition!"><code>HopTB.setposition!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">setposition!(
    tm::TBModel,
    R::AbstractVector{&lt;:Integer},
    n::Int64,
    m::Int64,
    α::Int64,
    pos::Number;
    position_tolerance::Real=1.0e-4
)</code></pre><p>Set ⟨0n|<span>$r_α$</span>|Rm⟩ to <code>pos</code> for <code>tm</code>. Overlap matrices must be set before this method is called if <code>tm</code> is not orthogonal.</p><p><code>position_tolerance</code> is used to check wehther the value is compatible with <code>tm.site_positions</code> (if not missing).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HopTB/HopTB.jl/blob/4dd0be7fb9f1f1b27dd50db5e4841284e56db10a/src/model.jl#L594-L612">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HopTB.getdH" href="#HopTB.getdH"><code>HopTB.getdH</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getdH(tm::AbstractTBModel, order::Tuple{Int64,Int64,Int64},
    k::AbstractVector{&lt;:Real})::Matrix{ComplexF64}</code></pre><p>Calculate <code>order</code> derivative of Hamiltonian.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HopTB/HopTB.jl/blob/4dd0be7fb9f1f1b27dd50db5e4841284e56db10a/src/basic.jl#L19-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HopTB.getdS" href="#HopTB.getdS"><code>HopTB.getdS</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getdS(tm::AbstractTBModel, order::Tuple{Int64,Int64,Int64},
    k::AbstractVector{&lt;:Real})::Matrix{ComplexF64}</code></pre><p>Calculate <code>order</code> derivative of overlap.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HopTB/HopTB.jl/blob/4dd0be7fb9f1f1b27dd50db5e4841284e56db10a/src/basic.jl#L62-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HopTB.getdAw" href="#HopTB.getdAw"><code>HopTB.getdAw</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getdAw(tm::AbstractTBModel, α::Int64, order::Tuple{Int64,Int64,Int64},
    k::AbstractVector{&lt;:Real})::Matrix{ComplexF64}</code></pre><p>Calculate <code>order</code> derivative of <span>$i⟨u_n^{(W)}|∂_{k_α}u_m^{(W)}⟩$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HopTB/HopTB.jl/blob/4dd0be7fb9f1f1b27dd50db5e4841284e56db10a/src/basic.jl#L91-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HopTB.getH" href="#HopTB.getH"><code>HopTB.getH</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getH(tm::AbstractTBModel, k::AbstractVector{&lt;:Real})::Matrix{ComplexF64}</code></pre><p>Calculate Hamiltonian at a reduced <code>k</code> point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HopTB/HopTB.jl/blob/4dd0be7fb9f1f1b27dd50db5e4841284e56db10a/src/basic.jl#L125-L131">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HopTB.getS" href="#HopTB.getS"><code>HopTB.getS</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getS(tm::AbstractTBModel, k::AbstractVector{&lt;:Real})::Matrix{ComplexF64}</code></pre><p>Calculate overlap matrix at a reduced <code>k</code> point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HopTB/HopTB.jl/blob/4dd0be7fb9f1f1b27dd50db5e4841284e56db10a/src/basic.jl#L137-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HopTB.geteig" href="#HopTB.geteig"><code>HopTB.geteig</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">geteig(tm::AbstractTBModel, k::AbstractVector{&lt;:Real})::HermEig</code></pre><p>Calculate eigenvalues and eigenvectors of <code>tm</code> at a reduced <code>k</code> point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HopTB/HopTB.jl/blob/4dd0be7fb9f1f1b27dd50db5e4841284e56db10a/src/basic.jl#L165-L171">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HopTB.getAw" href="#HopTB.getAw"><code>HopTB.getAw</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getAw(tm::AbstractTBModel, α::Int64, k::AbstractVector{&lt;:Real})::Matrix{ComplexF64}</code></pre><p>Calculate <span>$i⟨u_n^{(W)}|∂_{k_α}u_m^{(W)}⟩$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HopTB/HopTB.jl/blob/4dd0be7fb9f1f1b27dd50db5e4841284e56db10a/src/basic.jl#L184-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HopTB.getdEs" href="#HopTB.getdEs"><code>HopTB.getdEs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getdEs(tm::AbstractTBModel, α::Int64, k::AbstractVector{&lt;:Real})
--&gt;dEs::Vector{Float64}</code></pre><p>Calculate dE/dk for <code>tm</code> at <code>k</code> in the <code>α</code> direction.</p><p>Calculation method is provided in [Wang et al, 2019]. The relevant equation is Eq. (13). Although in that equation, there is no energy different denominator, it is still implicitly assumed that the band is nondegenerate. Therefore, dEs[n] is only correct if n is nondegenerate or completely degenerate.</p><p>This function is memoized, which means the arguments and results of the function should never be modified.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HopTB/HopTB.jl/blob/4dd0be7fb9f1f1b27dd50db5e4841284e56db10a/src/basic.jl#L252-L267">source</a></section><section><div><pre><code class="language-julia hljs">getdEs(
    tm::AbstractTBModel,
    α::Integer,
    β::Integer,
    k::AbstractVector{&lt;:Real}
) =&gt; dEs::Vector{Float64}</code></pre><p>Calculate d^2 E / dkα dkβ for <code>tm</code> at <code>k</code>. <code>α</code> and <code>β</code> are Cartesian directions.</p><p>dEs[n] is only correct if n is nondegenerate or completely degenerate.</p><p>This function is memoized, which means the arguments and results of the function should never be modified.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HopTB/HopTB.jl/blob/4dd0be7fb9f1f1b27dd50db5e4841284e56db10a/src/basic.jl#L280-L296">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HopTB.getA" href="#HopTB.getA"><code>HopTB.getA</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getA(tm::AbstractTBModel, α::Int64, k::AbstractVector{&lt;:Real})
--&gt;A::Matrix{ComplexF64}</code></pre><p>Calculate Berry connection <span>$i⟨u_n|∂_α|u_m⟩$</span> for <code>tm</code> at <code>k</code>.</p><p>Calculation method is provided in [Wang et al, 2019]. The relevant equation is Eq. (14). Since Eq. (14) assumes band m is nondegenerate, A[n, m] is only correct if m is nondegenerate or completely degenerate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HopTB/HopTB.jl/blob/4dd0be7fb9f1f1b27dd50db5e4841284e56db10a/src/basic.jl#L328-L339">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HopTB.getdr" href="#HopTB.getdr"><code>HopTB.getdr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function getdr(tm::AbstractTBModel, α::Int64, β::Int64, k::AbstractVector{&lt;:Real})
--&gt;dr::Matrix{ComplexF64}</code></pre><p>Compute <span>$∂_β r_α$</span> for <code>tm</code> at <code>k</code>. r[n, m] = A[n, m] if n != m and r[n, n] = 0.</p><p>dr is calculated by directly differentiating Eq. (14) of [Wang et al, 2019]. dr[n, m] is only correct when (i) both band n and band m are nondegenerate or (ii) both band n and band m are completely degenerate but <span>$E_n≠E_m$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HopTB/HopTB.jl/blob/4dd0be7fb9f1f1b27dd50db5e4841284e56db10a/src/basic.jl#L346-L357">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HopTB.getvelocity" href="#HopTB.getvelocity"><code>HopTB.getvelocity</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getvelocity(tm::AbstractTBModel, α::Int64, k::AbstractVector{&lt;:Number})</code></pre><p>Calculate velocity matrix in the α direction.</p><p>Velocity matrix is calculated by the following expression</p><p class="math-container">\[v_{nm}^α = ∂_α ϵ_n δ_{nm} + i (ϵ_n-ϵ_m) A_{nm}^α.\]</p><p>Therefore, the velocity is actually ħ*velocity.</p><p>v[n, m] is only correct when band m is nondegenerate or completely degenerate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HopTB/HopTB.jl/blob/4dd0be7fb9f1f1b27dd50db5e4841284e56db10a/src/basic.jl#L383-L397">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HopTB.getspin" href="#HopTB.getspin"><code>HopTB.getspin</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getspin(tm::AbstractTBModel, α::Int64, k::AbstractVector{&lt;:Real})</code></pre><p>Calculate ⟨n|σα|m⟩ at <code>k</code> point.</p><p>If <code>tm</code> is a TBModel, the function checks whether <code>tm.isspinful</code> is true.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HopTB/HopTB.jl/blob/4dd0be7fb9f1f1b27dd50db5e4841284e56db10a/src/basic.jl#L417-L425">source</a></section></article><h2 id="Documented-functions"><a class="docs-heading-anchor" href="#Documented-functions">Documented functions</a><a id="Documented-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Documented-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="HopTB.HermEig" href="#HopTB.HermEig"><code>HopTB.HermEig</code></a> — <span class="docstring-category">Type</span></header><section><div><p>HermEig wraps eigenvalues and eigenvectors of a Hermitian eigenvalue problem.</p><p><strong>Fields</strong></p><ul><li><code>values::Vector{Float64}</code>: eigenvalues</li><li><code>vectors::Matrix{ComplexF64}</code>: eigenvectors stored in column</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HopTB/HopTB.jl/blob/4dd0be7fb9f1f1b27dd50db5e4841284e56db10a/src/basic.jl#L149-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HopTB.change_energy_reference" href="#HopTB.change_energy_reference"><code>HopTB.change_energy_reference</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">change_energy_reference(tm::TBModel, μ::Number)::TBModel</code></pre><p>change zero energy reference to μ.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HopTB/HopTB.jl/blob/4dd0be7fb9f1f1b27dd50db5e4841284e56db10a/src/model.jl#L665-L671">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../model_tutorial/">« Model calculation</a><a class="docs-footer-nextpage" href="../optics/">Optics »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Monday 3 July 2023 00:59">Monday 3 July 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
