var documenterSearchIndex = {"docs":
[{"location":"magnetism/#HopTB.Magnetism","page":"Magnetism","title":"HopTB.Magnetism","text":"","category":"section"},{"location":"magnetism/","page":"Magnetism","title":"Magnetism","text":"HopTB.Magnetism.get_orbital_moment\nHopTB.Magnetism.get_field_modified_Es","category":"page"},{"location":"magnetism/#HopTB.Magnetism.get_orbital_moment","page":"Magnetism","title":"HopTB.Magnetism.get_orbital_moment","text":"get_orbital_moment(tm::AbstractTBModel, α::Int64, k::Vector{Float64})\n    --> M::Matrix{ComplexF64}\n\nThis function returns orbital magnetic moment in the unit of Bohr magneton\n\nM_nm=i m ϵ^αβγ sum_barl fracv_nl^β v_lm^γϵ_n-ϵ_l\n\nwhere either n = m or band n and band m are completely degenerate.\n\nM[n, m] would be set to zero if the above condition is not fulfilled.\n\nwarning: Warning\nThis function has not been tested.\n\n\n\n\n\n","category":"function"},{"location":"magnetism/#HopTB.Magnetism.get_field_modified_Es","page":"Magnetism","title":"HopTB.Magnetism.get_field_modified_Es","text":"get_field_modified_Es(tm::AbstractTBModel, α::Int64, B::Float64,\n    k::Vector{Float64}; double_degenerate=false)\n    --> mEs::Vector{Float64}\n\nCalculate modified energy due to orbital and spin Zeeman correction. If double_degenerate is true, the bands are assumed to be doubly degenerate. Otherwise the bands are assumed to be nondegenerate.\n\nwarning: Warning\nThis function has not been tested.\n\n\n\n\n\n","category":"function"},{"location":"optics/#HopTB.Optics","page":"Optics","title":"HopTB.Optics","text":"","category":"section"},{"location":"optics/","page":"Optics","title":"Optics","text":"HopTB.Optics.getpermittivity\nHopTB.Optics.get_shift_cond\nHopTB.Optics.get_shg\nHopTB.Optics.get_Drude_weight\nHopTB.Optics.cltberryconnection\nHopTB.Optics.cltshiftvector","category":"page"},{"location":"optics/#HopTB.Optics.getpermittivity","page":"Optics","title":"HopTB.Optics.getpermittivity","text":"getpermittivity(\n    tm::AbstractTBModel,\n    α::Int64,\n    β::Int64,\n    ωs::AbstractArray{<:Real,1},\n    μ::Float64,\n    meshsize::Vector{Int64};\n    ϵ::Float64=0.1,\n    batchsize::Int64=1\n) --> Vector{ComplexF64} \n\nCalculate relative permittivity.\n\nPermittivity is defined as\n\nχ^αβ=frace^2hbarfracd^3boldsymbolk(2π)^3sum_nm\n        fracf_nmr_nm^αr_mn^βω_mn-ω-iϵ\n\nThis function returns χ^αβϵ_0.\n\n\n\n\n\n","category":"function"},{"location":"optics/#HopTB.Optics.get_shift_cond","page":"Optics","title":"HopTB.Optics.get_shift_cond","text":"get_shift_cond(tm::AbstractTBModel, α::Int64, β::Int64, γ::Int64=β, ωs::Vector{Float64},\n    μ::Float64, nkmesh::Vector{Int64}; ϵ::Float64=0.1, batchsize::Int64=1)\n    --> Vector{Float64}\n\nCalculate shift conductivity.\n\nShift conductivity is defined as\n\nσ^αβγ(ω)=\nfracπe^3hbar^2fracdboldsymbolk(2π)^3sum_nm\nf_nmI_nm^αβγδ(ω_nm-ω)\n\nwhere\n\nI_nm^αβγ=Imr_mn^β r_nmα^γ+r_mn^γ r_nmα^β\n\nThis function returns shift conductivity in μA/V^2.\n\n\n\n\n\n","category":"function"},{"location":"optics/#HopTB.Optics.get_shg","page":"Optics","title":"HopTB.Optics.get_shg","text":"get_shg(tm::AbstractTBModel, α::Int64, β::Int64, γ::Int64, ωs::Vector{Float64},\n    μ::Float64, kmesh::Vector{Int64}; ϵ::Float64=0.1, scissor::Float64=0.0)\n    --> σs::Vector{ComplexF64}\n\nCalculate second harmonic generation.\n\nThe expression of second harmonic generation is in [Wang et al 2017].\n\nThe unit of σs is pm/V.\n\n\n\n\n\n","category":"function"},{"location":"optics/#HopTB.Optics.get_Drude_weight","page":"Optics","title":"HopTB.Optics.get_Drude_weight","text":"function get_Drude_weight(\n    tm::AbstractTBModel,\n    α::Integer,\n    β::Integer,\n    μ::Float64,\n    meshsize::AbstractVector{Int64};\n    kBT::Float64=0.01,\n    batchsize::Int64=1\n)\n\nThis function returns Drude weight in eV/(Ω⋅cm).\n\n\n\n\n\n","category":"function"},{"location":"optics/#HopTB.Optics.cltberryconnection","page":"Optics","title":"HopTB.Optics.cltberryconnection","text":"cltberryconnection(atm::AbstractTBModel, α::Int64, kpts::Matrix{Float64})\n    --> berryconnection\n\nCollect Berry connection for all k points.\n\nThe returned matrix berryconnection is berryconnection[n, m, ikpt] = |A[n, m]|^2 at ikpt.\n\n\n\n\n\n","category":"function"},{"location":"optics/#HopTB.Optics.cltshiftvector","page":"Optics","title":"HopTB.Optics.cltshiftvector","text":"cltshiftvector(atm::AbstractTBModel, α::Int64, β::Int64, kpts::Matrix{Float64})\n    --> shiftvector\n\nCollect shift vector matrices for all k points.\n\nshiftvector[n, m, ikpt] is the shift vector from band m to band n at ikpt.\n\nShift vector is defined to be\n\nR^αβ_nm = _αϕ_mn^β-A_mm^α+A_nn^α\n\n\n\n\n\n","category":"function"},{"location":"utilities/#HopTB.Utilities","page":"HopTB.Utilities","title":"HopTB.Utilities","text":"","category":"section"},{"location":"utilities/#Introduction","page":"HopTB.Utilities","title":"Introduction","text":"","category":"section"},{"location":"utilities/","page":"HopTB.Utilities","title":"HopTB.Utilities","text":"This module contains some useful functions.","category":"page"},{"location":"utilities/#Unexported-functions","page":"HopTB.Utilities","title":"Unexported functions","text":"","category":"section"},{"location":"utilities/","page":"HopTB.Utilities","title":"HopTB.Utilities","text":"HopTB.Utilities.integrate\nHopTB.Utilities.pintegrate","category":"page"},{"location":"utilities/#HopTB.Utilities.integrate","page":"HopTB.Utilities","title":"HopTB.Utilities.integrate","text":"integrate(f::Function; rtol::Float64=√eps(),\n    atol::Float64=0.0, maxevals::Int64=typemax(Int64))::Tuple\n\nIntegrate f from -∞ to ∞. The second argument of the returned tuple is error.\n\n\n\n\n\nintegrate(f::Function, x0::Vector{Float64}, x1::Vector{Float64};\n    constant_components::Vector{Int64}=zeros(Int64, 0), rtol::Float64=√eps(),\n    atol::Float64=0.0, maxevals::Int64=typemax(Int64), initdiv::Int64=1)\n\nIntegrate function f from x0 to x1 by HCubature package.\n\nf is a function that takes a Vector{Float64} and yields a number or a matrix. The error of integartion is estimated by norm(..., Inf). atol and rtol are absolute tolerance and respective tolerance respectively. The integration will stop whenever atol or rtol is reached or when maxevals evaluations of f have been done. Initially, the volume is divided into initdiv segments along each dimension.\n\nIt is common that f is independent on some components of its argument x, in this case, one can specify these components by constant_components and the integration will generally be boosted.\n\n\n\n\n\n","category":"function"},{"location":"utilities/#HopTB.Utilities.pintegrate","page":"HopTB.Utilities","title":"HopTB.Utilities.pintegrate","text":"pintegrate(f::Function, x0::Vector{Float64}, x1::Vector{Float64};\n    ndiv::Int64=1, constant_components::Vector{Int64}=zeros(Int64, 0),\n    rtol::Float64=√eps(), atol::Float64=0.0, maxevals::Int64=typemax(Int64),\n    initdiv::Int64=1)\n\nParallel integration of f. Most parameters have the same meaning as integrate. And the integration region is divided into ndiv segments in every dimension. The divided regions will be integrated on different processes.\n\n\n\n\n\n","category":"function"},{"location":"bs/#HopTB.BandStructure","page":"Band Structure","title":"HopTB.BandStructure","text":"","category":"section"},{"location":"bs/#Functions","page":"Band Structure","title":"Functions","text":"","category":"section"},{"location":"bs/","page":"Band Structure","title":"Band Structure","text":"HopTB.BandStructure.getbs\nHopTB.BandStructure.getdos\nHopTB.BandStructure.getjdos\nHopTB.BandStructure.clteig\nHopTB.BandStructure.get_fermi_surfaces","category":"page"},{"location":"bs/#HopTB.BandStructure.getbs","page":"Band Structure","title":"HopTB.BandStructure.getbs","text":"getbs(atm::AbstractTBModel, kpath::AbstractMatrix{Float64}, pnkpts::Int64;\n    connect_end_points::Bool=false)::(Vector{Float64}, Matrix{Float64})\n\nCalculate band structure along a kpath for atm. kpath is a matrix that marks start and end points of each line in columns, and pnkpts is the number of points in each line. if connect_end_points is true, end point of the previous segment is used as the start point of the next segment. This function returns (kdist, egvals), where kdist is the distance of k points in reciprocal space and egvals contains band energies stored in column for each k point.\n\n\n\n\n\n","category":"function"},{"location":"bs/#HopTB.BandStructure.getdos","page":"Band Structure","title":"HopTB.BandStructure.getdos","text":"getdos(tm::AbstractTBModel, ωs::AbstractVector{Float64}, nkmesh::Vector{Int64};\n    ϵ::Float64=0.1) --> dos::Vector{Float64}\n\nCalculate density of states by a nkmesh mesh in reciprocal space.\n\nThe density of states is defined as\n\nν(ω) = sum_n int fracmathrmdboldsymbolk(2pi)^3 δ(E_nboldsymbolk-ω)\n\nϵ is the broadening of the delta function.\n\ndos is in the unit of 1/(eV*Å^3).\n\n\n\n\n\ngetdos(\n    tm::AbstractTBModel,\n    em::EnergyMesh,\n    ωs::AbstractVector{Float64};\n    ϵ::Float64=0.1\n)\n\nCompute density of states from an energy mesh.\n\n\n\n\n\n","category":"function"},{"location":"bs/#HopTB.BandStructure.getjdos","page":"Band Structure","title":"HopTB.BandStructure.getjdos","text":"getjdos(tm::AbstractTBModel, ωs::Vector{Float64}, μ::Float64,\n    nkmesh::Vector{Int64}; ϵ::Float64=0.1)\n\nCalculate joint density of states between valence and conduction band.\n\nJoint density of states is defined as\n\nfracdmathbfk(2π)^3sum_nmf_mnδ(E_n-E_m-ω)\n\n\n\n\n\n","category":"function"},{"location":"bs/#HopTB.BandStructure.clteig","page":"Band Structure","title":"HopTB.BandStructure.clteig","text":"clteig(tm::AbstractTBModel, nkmesh::Vector{Int64}; bandinds::Vector{Int64}=collect(1:tm.norbits))\n\nCollect eigenvalues of bands denoted by bandinds on the kmesh defined by nkmesh. This function returns a 4D SharedArray:     first index -> bands;     second-fourth index -> k point.\n\nFor example, with nkmesh being [10, 10, 10], Es[3, 4, 5, 6] is the third eigenvalue at k point [0.3, 0.4, 0.5].\n\n\n\n\n\n","category":"function"},{"location":"bs/#HopTB.BandStructure.get_fermi_surfaces","page":"Band Structure","title":"HopTB.BandStructure.get_fermi_surfaces","text":"function get_fermi_surfaces(\n    tm::AbstractTBModel,\n    em::EnergyMesh;\n    fermi_energy::Real=0.0,\n    band_indices::AbstractVector{Int64}=em.band_indices\n)::Vector{FermiSurface}\n\nCalculate Fermi surfaces from the energy mesh em for bands designated with band_indices.\n\nThe Fermi surfaces are extracted by Marching Tetrahedra method.\n\n\n\n\n\nfunction get_fermi_surfaces(\n    tm::AbstractTBModel,\n    meshsize::AbstractVector{Int64},\n    band_indices::AbstractVector{Int64};\n    fermi_energy::Real=0.0,\n    batchsize::Int64=1\n)::Vector{FermiSurface}\n\nCalculate Fermi surfaces (with Fermi energy fermi_energy) for bands (specified by band_indices) for tm. The Fermi surfaces are extracted by Marching Tetrahedra method on a uniform mesh specified by meshsize.\n\n\n\n\n\n","category":"function"},{"location":"floquet/#HopTB.Floquet","page":"HopTB.Floquet","title":"HopTB.Floquet","text":"","category":"section"},{"location":"floquet/","page":"HopTB.Floquet","title":"HopTB.Floquet","text":"HopTB.Floquet.FTBModel\nHopTB.Floquet.getFTBModel\nHopTB.Floquet.addlight","category":"page"},{"location":"floquet/#HopTB.Floquet.FTBModel","page":"HopTB.Floquet","title":"HopTB.Floquet.FTBModel","text":"mutable struct FTBModel{T<:Number}\n    Ω::Float64\n    tm::TBModel{T}\n    num_independent_orbits::Int64\n    forder::Int64\nend\n\nFTBModel is a struct representing a Floquet tight binding model, which is is a tight binding model (whose number of orbits being num_independent_orbits) with a periodic Hamiltonian (frequency being Ω). A Floquet tight binding model can be mapped to a tight binding model with an electric field, stored as tm. tm should in principle have infinite number of orbits and we cut off tm from -forder to forder in the frequency dimension.\n\nThe basis function for tm is |n⟩e^{-ilΩt}, where n labels tight binding orbitals of the original model. The basis function above corresponds to the (l+forder)*num_independent_orbits+n row/column in the matrix.\n\n\n\n\n\n","category":"type"},{"location":"floquet/#HopTB.Floquet.getFTBModel","page":"HopTB.Floquet","title":"HopTB.Floquet.getFTBModel","text":"function getFTBModel(tm::TBModel{T}, Ω::Float64, forder::Int64;\n    keep_original_hoppings::Bool=false) where T<:Number\n\nConstruct a FTBModel from a TBModel.\n\n\n\n\n\n","category":"function"},{"location":"floquet/#HopTB.Floquet.addlight","page":"HopTB.Floquet","title":"HopTB.Floquet.addlight","text":"A(t) = real(A*exp(iΩt))\n\n⟨0n|H'(t)|Rm⟩ = ⟨0n|H|Rm⟩exp(im(A(t)⋅(R+rm-rn))) where the negative charge of electron has been taken into account.\n\n\n\n\n\n","category":"function"},{"location":"hop/#HopTB","page":"HopTB","title":"HopTB","text":"","category":"section"},{"location":"hop/#Exported-functions","page":"HopTB","title":"Exported functions","text":"","category":"section"},{"location":"hop/","page":"HopTB","title":"HopTB","text":"HopTB.TBModel\nHopTB.SharedTBModel\nHopTB.sethopping!\nHopTB.addhopping!\nHopTB.setoverlap!\nHopTB.setposition!\nHopTB.getdH\nHopTB.getdS\nHopTB.getdAw\nHopTB.getH\nHopTB.getS\nHopTB.geteig\nHopTB.getAw\nHopTB.getdEs\nHopTB.getA\nHopTB.getdr\nHopTB.getvelocity\nHopTB.getspin","category":"page"},{"location":"hop/#HopTB.TBModel","page":"HopTB","title":"HopTB.TBModel","text":"TBModel{T<Number} is a data type representing tight binding models.\n\nFields\n\nnorbits::Int64: number of orbits in the model\nlat::SMatrix{3,3,Float64,9}: primitive lattice vectors stored in columns\nrlat::SMatrix{3,3,Float64,9}: primitive reciprocal lattice vectors stored in columns\nhoppings::Dict{SVector{3,Int16},Matrix{T}}: R -> ⟨0n|H|Rm⟩, where n is the first index and m is the second index.\noverlaps::Dict{SVector{3,Int16},Matrix{T}}: R -> ⟨0n|Rm⟩\npositions::Dict{SVector{3,Int16},SVector{3,Matrix{T}}}: R -> [⟨0n|rx|Rm⟩, ⟨0n|ry|Rm⟩, ⟨0n|rz|Rm⟩]\nisorthogonal: whether the different orbitals of the model is orthogonal to each other.\nnsites::Union{Missing,Int16}: It is possible that the orbitals can be grouped into several sites. Every group of orbitals should share the same position within the group, stored in site_positions.\nsite_norbits::Union{Missing,Vector{Int64}}: number of orbitals for each site.\nsite_positions::Union{Missing,Matrix{Float64}}: position of sites stored in column\norbital_types::Union{Missing,Vector{Vector{Int16}}}: It is possible that the orbitals have definite symmetry representations. Example: orbital_types = [[0], [0, 1]] denotes that there are two sites, the first of which has 1 s orbital and the second of which has 1 s orbital and 1 p orbital (4 orbitals in total not counting spin). The orbitals of the TBModel should appear in a consistent order denoted by orbital_types.\nisspinful::Union{Missing,Bool}: If a TBModel is spinful, the first half of the orbitals should be spin up and the second half should be spin down. The two halves of the orbitals should be in one-to-one correspondence.\nis_canonical_ordered::Union{Missing,Bool}: If the orbital types are know, and is_canonical_ordered is true, then the orbitals are guaranteed to appear in a canonical order defined by decreasing Lz value. For example, canonical order of p orbitals should -px-ipy, pz, px-ipy. See the wikipedia for other orbitals.\n\nMissing data\n\nNot all fields of TBModels are required to have a valid value. For example, it is possible the site information is missing for some models. Here are some rules:\n\nnsites, site_norbits, site_positions should all either be missing or valid.\norbital_types can only be valid if nsites, site_norbits and site_positions are valid.\nis_canonical_ordered can only be valid if orbital_types is valid.\n\nConsistency check\n\nAny functions that directly modifies a TBModel should always maintain the following consistencies (if relevant fields are not missing):\n\nhoppings, overlaps and positions matrices should always be Hermitian.\noverlap[[0, 0, 0]] should always be positive definite.\ndiag(position[[0, 0, 0]][α])/diag(overlap[[0, 0, 0]]) should be consistent with site_positions.\nnumber of orbits should be consistent.\n\n\n\n\n\n","category":"type"},{"location":"hop/#HopTB.SharedTBModel","page":"HopTB","title":"HopTB.SharedTBModel","text":"SharedTBModel is a data type that encodes all the information of a TBModel into several SharedArrays.\n\nSharedTBModel is generally more efficient than TBModel. A typical workflow is to construct TBModel and then convert it into a SharedTBModel for large scale calculations.\n\nFields\n\nnorbits::Int64: number of orbits\nisorthogonal::Bool: whether orbits of the model are orthonormal\nlat::SMatrix{3,3,Float64,9}: primitive lattice vectors stored in columns\nrlat::SMatrix{3,3,Float64,9}: primitive reciprocal lattice vectors stored in columns\nRs::Matrix{Int16}: R vectors stored in columns for hopping, overlap and position matrices. The number of R vectors is odd. The first R vector is [0, 0, 0]. For the rest of the matrix Rs[:, 2:end], the first half and the second half is guaranteed to be in one-to-one correspondence R <-> -R.\nRcs::Matrix{Float64}: R vectors in Cartesian coordinates.\nH::SharedArray{T,2}: H = reshape(Hmatrix, (norbits * norbits, :)). Hmatrix[:, :, iR] is ⟨0n|H|Rm⟩ where R is Rs[:, iR]. Since Hamiltonian is Hermitian, only first half R vectors in Rs are stored. In addition, Hmatrix[:, :, 1] is different: Hmatrix[:, :, 1] is ⟨0n|H|0m⟩/2.\nS::Union{Nothing,SharedArray{T,3}}: S = reshape(Smatrix, (norbits * norbits, :)). Smatrix[:, :, iR] is ⟨0n|Rm⟩ where R is Rs[:, iR]. Since overlap matrix is Hermitian, only first half R vectors in Rs are stored. In addition, Smatrix[:, :, 1] is different: Smatrix[:, :, 1] is ⟨0n|0m⟩/2. \nr:SVector{3,SharedArray{T,2}}: S[α] = reshape(Smatrices[α], (norbits * norbits, :)). Smatrices[α][:, :, iR] is ⟨0n|rα|Rm⟩ where R is Rs[:, iR].\n\n\n\n\n\n","category":"type"},{"location":"hop/#HopTB.sethopping!","page":"HopTB","title":"HopTB.sethopping!","text":"sethopping!(ftm::FTBModel, R::AbstractVector{Int64}, n::Int64, m::Int64,\n    p::Int64, hopping::Number)\n\nSet ⟨⟨0; n e^{-ilΩt}|H(t)|R; m e^{-i(l-p)Ωt}⟩⟩ to hopping for all l. Alternatively, hopping is ⟨n|H(p)|m⟩, where H(t) = ∑H(p)e^{-ipΩt}.\n\nThe Floquet Hamiltonian HF=H-i∂t, in the basis functions |n⟩e^{-ilΩt}, is (HF){l, l-p}=⟨⟨0; n e^{-ilΩt}|H(t)|R; m e^{-i(l-p)Ωt}⟩⟩-δ{p,0}lΩ. This function automatically handles the above δ function.\n\n\n\n\n\nsethopping!(tm::TBModel{T}, R::AbstractVector{<:Integer}, n::Int64, m::Int64,\n    hopping::Number) where T\n\nSet ⟨0n|H|Rm⟩ to hopping for tm.\n\n\n\n\n\n","category":"function"},{"location":"hop/#HopTB.addhopping!","page":"HopTB","title":"HopTB.addhopping!","text":"addhopping!(ftm::FTBModel, R::AbstractVector{Int64}, n::Int64, m::Int64,\n    p::Int64, hopping::Number)\n\nAdd hopping to ⟨⟨0; n e^{-ilΩt}|H(t)|R; m e^{-i(l-p)Ωt}⟩⟩.\n\nThis function does not add the onsite energy due to periodic driving.\n\n\n\n\n\naddhopping!(tm::TBModel, R::AbstractVector{<:Integer}, hopping::Matrix{<:Number})\n\nAdd hopping to the Hamiltonian of tm.\n\nhopping should be a (tm.norbits, tm.norbits) array containing the matrix ⟨0n|H|Rm⟩ with n and m indices. If R is [0, 0, 0], then hopping needs to be Hermitian.\n\n\n\n\n\n","category":"function"},{"location":"hop/#HopTB.setoverlap!","page":"HopTB","title":"HopTB.setoverlap!","text":"setoverlap!(tm::TBModel{T}, R::AbstractVector{<:Integer}, n::Int64, m::Int64,\n    overlap::Number) where T\n\nSet ⟨0n|Rm⟩ to overlap for tm.\n\n\n\n\n\n","category":"function"},{"location":"hop/#HopTB.setposition!","page":"HopTB","title":"HopTB.setposition!","text":"setposition!(\n    tm::TBModel,\n    R::AbstractVector{<:Integer},\n    n::Int64,\n    m::Int64,\n    α::Int64,\n    pos::Number;\n    position_tolerance::Real=1.0e-4\n)\n\nSet ⟨0n|r_α|Rm⟩ to pos for tm. Overlap matrices must be set before this method is called if tm is not orthogonal.\n\nposition_tolerance is used to check wehther the value is compatible with tm.site_positions (if not missing).\n\n\n\n\n\n","category":"function"},{"location":"hop/#HopTB.getdH","page":"HopTB","title":"HopTB.getdH","text":"getdH(tm::AbstractTBModel, order::Tuple{Int64,Int64,Int64},\n    k::AbstractVector{<:Real})::Matrix{ComplexF64}\n\nCalculate order derivative of Hamiltonian.\n\n\n\n\n\n","category":"function"},{"location":"hop/#HopTB.getdS","page":"HopTB","title":"HopTB.getdS","text":"getdS(tm::AbstractTBModel, order::Tuple{Int64,Int64,Int64},\n    k::AbstractVector{<:Real})::Matrix{ComplexF64}\n\nCalculate order derivative of overlap.\n\n\n\n\n\n","category":"function"},{"location":"hop/#HopTB.getdAw","page":"HopTB","title":"HopTB.getdAw","text":"getdAw(tm::AbstractTBModel, α::Int64, order::Tuple{Int64,Int64,Int64},\n    k::AbstractVector{<:Real})::Matrix{ComplexF64}\n\nCalculate order derivative of iu_n^(W)_k_αu_m^(W).\n\n\n\n\n\n","category":"function"},{"location":"hop/#HopTB.getH","page":"HopTB","title":"HopTB.getH","text":"getH(tm::AbstractTBModel, k::AbstractVector{<:Real})::Matrix{ComplexF64}\n\nCalculate Hamiltonian at a reduced k point.\n\n\n\n\n\n","category":"function"},{"location":"hop/#HopTB.getS","page":"HopTB","title":"HopTB.getS","text":"getS(tm::AbstractTBModel, k::AbstractVector{<:Real})::Matrix{ComplexF64}\n\nCalculate overlap matrix at a reduced k point.\n\n\n\n\n\n","category":"function"},{"location":"hop/#HopTB.geteig","page":"HopTB","title":"HopTB.geteig","text":"geteig(tm::AbstractTBModel, k::AbstractVector{<:Real})::HermEig\n\nCalculate eigenvalues and eigenvectors of tm at a reduced k point.\n\n\n\n\n\n","category":"function"},{"location":"hop/#HopTB.getAw","page":"HopTB","title":"HopTB.getAw","text":"getAw(tm::AbstractTBModel, α::Int64, k::AbstractVector{<:Real})::Matrix{ComplexF64}\n\nCalculate iu_n^(W)_k_αu_m^(W).\n\n\n\n\n\n","category":"function"},{"location":"hop/#HopTB.getdEs","page":"HopTB","title":"HopTB.getdEs","text":"getdEs(tm::AbstractTBModel, α::Int64, k::AbstractVector{<:Real})\n-->dEs::Vector{Float64}\n\nCalculate dE/dk for tm at k in the α direction.\n\nCalculation method is provided in [Wang et al, 2019]. The relevant equation is Eq. (13). Although in that equation, there is no energy different denominator, it is still implicitly assumed that the band is nondegenerate. Therefore, dEs[n] is only correct if n is nondegenerate or completely degenerate.\n\nThis function is memoized, which means the arguments and results of the function should never be modified.\n\n\n\n\n\ngetdEs(\n    tm::AbstractTBModel,\n    α::Integer,\n    β::Integer,\n    k::AbstractVector{<:Real}\n) => dEs::Vector{Float64}\n\nCalculate d^2 E / dkα dkβ for tm at k. α and β are Cartesian directions.\n\ndEs[n] is only correct if n is nondegenerate or completely degenerate.\n\nThis function is memoized, which means the arguments and results of the function should never be modified.\n\n\n\n\n\n","category":"function"},{"location":"hop/#HopTB.getA","page":"HopTB","title":"HopTB.getA","text":"getA(tm::AbstractTBModel, α::Int64, k::AbstractVector{<:Real})\n-->A::Matrix{ComplexF64}\n\nCalculate Berry connection iu_n_αu_m for tm at k.\n\nCalculation method is provided in [Wang et al, 2019]. The relevant equation is Eq. (14). Since Eq. (14) assumes band m is nondegenerate, A[n, m] is only correct if m is nondegenerate or completely degenerate.\n\n\n\n\n\n","category":"function"},{"location":"hop/#HopTB.getdr","page":"HopTB","title":"HopTB.getdr","text":"function getdr(tm::AbstractTBModel, α::Int64, β::Int64, k::AbstractVector{<:Real})\n-->dr::Matrix{ComplexF64}\n\nCompute _β r_α for tm at k. r[n, m] = A[n, m] if n != m and r[n, n] = 0.\n\ndr is calculated by directly differentiating Eq. (14) of [Wang et al, 2019]. dr[n, m] is only correct when (i) both band n and band m are nondegenerate or (ii) both band n and band m are completely degenerate but E_nE_m.\n\n\n\n\n\n","category":"function"},{"location":"hop/#HopTB.getvelocity","page":"HopTB","title":"HopTB.getvelocity","text":"getvelocity(tm::AbstractTBModel, α::Int64, k::AbstractVector{<:Number})\n\nCalculate velocity matrix in the α direction.\n\nVelocity matrix is calculated by the following expression\n\nv_nm^α = _α ϵ_n δ_nm + i (ϵ_n-ϵ_m) A_nm^α\n\nTherefore, the velocity is actually ħ*velocity.\n\nv[n, m] is only correct when band m is nondegenerate or completely degenerate.\n\n\n\n\n\n","category":"function"},{"location":"hop/#HopTB.getspin","page":"HopTB","title":"HopTB.getspin","text":"getspin(tm::AbstractTBModel, α::Int64, k::AbstractVector{<:Real})\n\nCalculate ⟨n|σα|m⟩ at k point.\n\nIf tm is a TBModel, the function checks whether tm.isspinful is true.\n\n\n\n\n\n","category":"function"},{"location":"hop/#Documented-functions","page":"HopTB","title":"Documented functions","text":"","category":"section"},{"location":"hop/","page":"HopTB","title":"HopTB","text":"HopTB.HermEig\nHopTB.change_energy_reference","category":"page"},{"location":"hop/#HopTB.HermEig","page":"HopTB","title":"HopTB.HermEig","text":"HermEig wraps eigenvalues and eigenvectors of a Hermitian eigenvalue problem.\n\nFields\n\nvalues::Vector{Float64}: eigenvalues\nvectors::Matrix{ComplexF64}: eigenvectors stored in column\n\n\n\n\n\n","category":"type"},{"location":"hop/#HopTB.change_energy_reference","page":"HopTB","title":"HopTB.change_energy_reference","text":"change_energy_reference(tm::TBModel, μ::Number)::TBModel\n\nchange zero energy reference to μ.\n\n\n\n\n\n","category":"function"},{"location":"group/#HopTB.Group","page":"Symmetrization of TB model","title":"HopTB.Group","text":"","category":"section"},{"location":"group/","page":"Symmetrization of TB model","title":"Symmetrization of TB model","text":"HopTB.Group.Symmetry\nHopTB.Group.inverse\nHopTB.Group.gettranslation\nHopTB.Group.getrotation\nHopTB.Group.getTRS\nHopTB.Group.getmirror\nHopTB.Group.decompose_to_primitive\nHopTB.Group.generategroup\nHopTB.Group.symmetrize\nHopTB.Group.get_bloch_rep","category":"page"},{"location":"group/#HopTB.Group.Symmetry","page":"Symmetrization of TB model","title":"HopTB.Group.Symmetry","text":"Symmetry(rotation_matrix, translation, spin_rep;\n    isantilinear::Bool=false, isdouble::Bool=false)\n\nType representing symmetries. The symmetry is a magnetic space group symmetry, i.e., symmetry containing rotation, reflection, inversion, translation and time reversal. The defining feature for magnetic space group symmetry is its represention in real space (rotation_matrix and translation, where translation operation follows the the action of rotation_matrix) and its representation in spinors. The symmetry may belong to a double group (isdouble=true) or not (isdouble=false). If the symmetry does not belong to a double group, it is only relevant for spinless fermions and the spin_rep information is not used at all. The symmetry may be antilinear denoted by the keyword isantilinear.\n\n\n\n\n\n","category":"type"},{"location":"group/#HopTB.Group.inverse","page":"Symmetrization of TB model","title":"HopTB.Group.inverse","text":"inverse(s::Symmetry)\n\nGet inverse symmetry operation for s.\n\n\n\n\n\n","category":"function"},{"location":"group/#HopTB.Group.gettranslation","page":"Symmetrization of TB model","title":"HopTB.Group.gettranslation","text":"gettranslation(v::Vector{<:Real}; isdouble::Bool=false)\n\nget translation along v.\n\n\n\n\n\n","category":"function"},{"location":"group/#HopTB.Group.getrotation","page":"Symmetrization of TB model","title":"HopTB.Group.getrotation","text":"getrotation(θ::Real, axis::Vector{<:Real}; isdouble::Bool=false)\n\nget θ rotation around the axis.\n\n\n\n\n\n","category":"function"},{"location":"group/#HopTB.Group.getTRS","page":"Symmetrization of TB model","title":"HopTB.Group.getTRS","text":"getTRS(; isdouble::Bool=false)\n\nget time reversal symmetry.\n\n\n\n\n\n","category":"function"},{"location":"group/#HopTB.Group.getmirror","page":"Symmetrization of TB model","title":"HopTB.Group.getmirror","text":"getmirror(axis::Vector{<:Real}; isdouble::Bool=false) -> Symmetry\n\nget mirror symmetry along `axis`.\n\n\n\n\n\n","category":"function"},{"location":"group/#HopTB.Group.decompose_to_primitive","page":"Symmetrization of TB model","title":"HopTB.Group.decompose_to_primitive","text":"decompose_to_primitive(s::Symmetry)\n\nEvery magnetic space group symmetry can be decomposed into a canonical representation, i.e., ĒtICT, where T is time reversal, C is rotation, I is inversion, t is translation and Ē is 2π rotation. This function decomposes the symmetry to these atomic actions. This function always treats the symmetry as a double group symmetry.\n\nThe returned named tuple are in the following format\n\n(TRS::Bool, inversion::Bool, translation::Vector{Float64}, θ::Float64,\n    axis::Vector{Float64}, Ē::Bool)\n\n\n\n\n\n","category":"function"},{"location":"group/#HopTB.Group.generategroup","page":"Symmetrization of TB model","title":"HopTB.Group.generategroup","text":"generategroup(symmetries::Vector{Symmetry}; maxiter=100)::Vector{Symmetry}\n\ngenerate a group with generators symmetries.\n\n\n\n\n\n","category":"function"},{"location":"group/#HopTB.Group.symmetrize","page":"Symmetrization of TB model","title":"HopTB.Group.symmetrize","text":"symmetrize(tm::TBModel, g::Vector{Symmetry})\n\nSymmetrize tm by the symmetry group g.\n\n\n\n\n\n","category":"function"},{"location":"group/#HopTB.Group.get_bloch_rep","page":"Symmetrization of TB model","title":"HopTB.Group.get_bloch_rep","text":"get_bloch_rep(s::Symmetry, tm::TBModel, orbital_types::Vector{Vector{Int64}},\n    k::Vector{<:Real}; isspinful::Bool=false)\n\n\n\n\n\n","category":"function"},{"location":"topology/#HopTB.Topology","page":"Topology","title":"HopTB.Topology","text":"","category":"section"},{"location":"topology/#exported-functions","page":"Topology","title":"exported functions","text":"","category":"section"},{"location":"topology/","page":"Topology","title":"Topology","text":"HopTB.Topology.get_smooth_gauge\nHopTB.Topology.get_wilson_spectrum","category":"page"},{"location":"topology/#HopTB.Topology.get_smooth_gauge","page":"Topology","title":"HopTB.Topology.get_smooth_gauge","text":"get_smooth_gauge(tm::TBModel, getv::Function, v0::Vector{<:Number},\n    kpts::Matrix{<:Real}; unwind::Bool=false)::Matrix{ComplexF64}\n\nParallel transport the Bloch function produced by getv at a line in BZ denoted by kpts. The start point is kpts[:, 1] where the vector is assumed to be v0. If unwind is true, then the first k point in kpts and the last k point in kpts are assumed to be identical k point. In this case, the vector on the two k points are made the same. kpts are assumed to be even spaced if unwind is true.\n\nThe output is a matrix of size (length(v0), length(kpts)).\n\n\n\n\n\nget_smooth_gauge(tm::TBModel, getv::Function, nkmesh::Vector{Int64})\n\nFind a smooth gauge in the BZ for the Bloch functions returned by getv. Please make sure Chern number is 0 for any possible submanifold.\n\n\n\n\n\nget_smooth_gauge(tm::TBModel, bandind::Int64, nkmesh::Vector{Int64})\n\nFind a smooth gauge in the BZ for the bandind band. Please make sure Chern number is 0 for any possible submanifold.\n\n\n\n\n\n","category":"function"},{"location":"topology/#HopTB.Topology.get_wilson_spectrum","page":"Topology","title":"HopTB.Topology.get_wilson_spectrum","text":"function get_wilson_spectrum(\n    tm::AbstractTBModel,\n    band_indices::Vector{<:Integer},\n    kpaths::AbstractMatrix{<:Real},\n    ndiv::Int64\n)\n\nCalculate Wilson loop spectrum for bands labelled by band_indices on kpaths.\n\nWilson loop spectrum is defined as the eigenvalues of the parallel transport operator W. Specifically, W is a unitary operator and its eigenvalues are of the form exp(iθ). This function returns {θ}.\n\nW is defined as a product of projection operators: P_kN * ... * P_k2 * P_k1. Here, P is the projection operator onto bands labelled by band_indices. The path  k1 -> k2 -> ... -> kN is specified by kpaths and ndiv. Specifically, this path is kpath[:, 1] -> ... -> kpath[:, 2] -> ... -> kpath[:, end], where ndiv k points are inserted between kpath[:, i] and kpath[:, i + 1].\n\n\n\n\n\n","category":"function"},{"location":"wannier/#HopTB.Utilities","page":"HopTB.Utilities","title":"HopTB.Utilities","text":"","category":"section"},{"location":"wannier/#Introduction","page":"HopTB.Utilities","title":"Introduction","text":"","category":"section"},{"location":"wannier/","page":"HopTB.Utilities","title":"HopTB.Utilities","text":"This module constructs Wannier functions.","category":"page"},{"location":"wannier/#exported-functions","page":"HopTB.Utilities","title":"exported functions","text":"","category":"section"},{"location":"wannier/","page":"HopTB.Utilities","title":"HopTB.Utilities","text":"HopTB.Wannier.getwf\nHopTB.Wannier.interpolatewf","category":"page"},{"location":"wannier/#HopTB.Wannier.getwf","page":"HopTB.Utilities","title":"HopTB.Wannier.getwf","text":"getwf(getvs::Function, Rs::AbstractMatrix{Int64}; rtol::Float64=√eps(),\n    atol::Float64=0.0, constant_components::Vector{Int64}=zeros(Int64, 0),\n    ndiv::Int64=1)\n\nCalculate Wannier functions in the home unit cell.\n\ngetvs should be a function that takes a three-component vector k as argument and yields a matrix (orbitalindex, bandindex). Wannier functions will only be computed at Rs. The other parameters are directly sent to HopTB.Wannier.pintegrate.\n\n\n\n\n\ngetwf(tm::TBModel, twfs::Dict{Vector{Int64}, Matrix{T}},\n    bands::Vector{Int64}, Rs::AbstractMatrix{Int64}; tol::Float64=0.1, rtol::Float64=√eps(),\n    atol::Float64=0.0, constant_components::Vector{Int64}=zeros(Int64, 0), ndiv::Int64=1) where T<:Number\n\nCalculate Wannier functions with trial Wannier functions in twfs.\n\nThe project orthogonalization procedure has a tolerance tol. Other keyword arguments are directly sent to HopTB.Wannier.pintegrate.\n\n\n\n\n\ngetwf(getvs::Function, nkmesh::Vector{Int64}, nrmesh::Vector{Int64})\n\nCalculate home unit cell Wannier functions with k mesh nkmesh.\n\nWannier functions are only computed at unit cells denoted by nrmesh.\n\n\n\n\n\ngetwf(tm::TBModel, twfs::Dict{Vector{Int64}, Matrix{T}},\n    bands::Vector{Int64}, nkmesh::Vector{Int64},\n    nrmesh::Vector{Int64}; tol::Float64=0.01) where T<:Number\n\nCalculate Wannier functions for bands indexed by bands.\n\nBoth returned Wannier functions and lfs are stored in format {R: ⟨Rn|gm⟩}, where g are localized (Wannier) functions.\n\n\n\n\n\n","category":"function"},{"location":"wannier/#HopTB.Wannier.interpolatewf","page":"HopTB.Utilities","title":"HopTB.Wannier.interpolatewf","text":"interpolatewf(gettm, tmparams::Matrix{<:Number},\n    twfs::Dict{Vector{Int64}, Matrix{T}}, bands::Vector{Int64},\n    nkmesh::Vector{Int64}, nrmesh::Vector{Int64}, ndiv::Int64) where T<:Number\n\nCalculate Wannier functions by interpolation between tight binding models.\n\ngettm is a function taking parameters and returning tight binding models. With the parameters stored in column in tmparams, the Wannier function is obtained by interpolation. More precisely, the twfs are used for initial guess and Wannier functions from last step is used as trial Wannier function for the next step.\n\n\n\n\n\n","category":"function"},{"location":"wannier/#Unexported-functions","page":"HopTB.Utilities","title":"Unexported functions","text":"","category":"section"},{"location":"wannier/","page":"HopTB.Utilities","title":"HopTB.Utilities","text":"HopTB.Wannier.inner\nHopTB.Wannier.project_orthogonalize","category":"page"},{"location":"wannier/#HopTB.Wannier.inner","page":"HopTB.Utilities","title":"HopTB.Wannier.inner","text":"inner(vs::Matrix{ComplexF64}, lfs::Dict{Vector{Int64}, Matrix{T}},\n    k::Vector{<:Real}) where T<:Number\n\nCalculate ⟨ψnk|gm⟩, where g is a localized wave function. lfs is stored in format {R: ⟨Rn|gm⟩}.\n\n\n\n\n\n","category":"function"},{"location":"wannier/#HopTB.Wannier.project_orthogonalize","page":"HopTB.Utilities","title":"HopTB.Wannier.project_orthogonalize","text":"project_orthogonalize(vs::Matrix{ComplexF64},\n    lfs::Dict{Vector{Int64}, Matrix{T}}, k::Vector{<:Real};\n    tol::Float64=0.01) where T<:Number\n\nGet a new Bloch basis by project the Bloch wave functions onto localized functions.\n\nThe returned matrix stores ⟨ψm^(W)|φn⟩ in column, where φ_n is the new Bloch basis.\n\n\n\n\n\n","category":"function"},{"location":"response/#HopTB.Response","page":"HopTB.Response","title":"HopTB.Response","text":"","category":"section"},{"location":"response/","page":"HopTB.Response","title":"HopTB.Response","text":"HopTB.Response.getresponse\nHopTB.Response.get_Floquet_response\nHopTB.Response.clt_Floquet_response","category":"page"},{"location":"response/#HopTB.Response.getresponse","page":"HopTB.Response","title":"HopTB.Response.getresponse","text":"getresponse(getH::Function, getO::Function, getV::Function,\n    getn::Function, k::AbstractVector{Float64}; Γ::Float64=0.1, atol::Float64=0.0,\n    maxevals::Int64=typemax{Int64})\n\nCalculate response at k.\n\nThe response is the linear change of ⟨O⟩ due to V added to the original Hamiltonian. getH, getO and getV all take k as the only argument and output corresponding matrices.\n\nΓ is the broadening factor. If the every degree of the system is coupled to a wide-band heat bath, Γ=i T^2 ν, where T is the hopping constant between the system and the heat bath and ν is the density of states of the heat bath. The heat bath has a occupation distribution getn(ω).\n\nThe integration over ω would have an absolute tolerance atol, with maximal evaluation number being maxevals.\n\n\n\n\n\ngetresponse(getH::Function, getO::Function, getV::Function,\n    getn::Function, nkmesh::Vector{Int64}; Γ::Float64=0.1, atol::Float64=0.0,\n    maxevals::Int64=typemax(Int64), offset::Vector{Float64}=[0.0, 0.0, 0.0],\n    k1::Vector{Float64}=[0.0, 0.0, 0.0], k2::Vector{Float64}=[1.0, 1.0, 1.0])\n\nCalculate response.\n\nThe response is the linear change of ⟨O⟩ due to V added to the original Hamiltonian. getH, getO and getV all take k as the only argument and output corresponding matrices.\n\nΓ is the broadening factor. If the every degree of the system is coupled to a wide-band heat bath, Γ=i T^2 ν, where T is the hopping constant between the system and the heat bath and ν is the density of states of the heat bath. The heat bath has a occupation distribution getn(ω).\n\nThe response function is integrated in a rectangle with corners k1 and k2. The mesh is nkmesh and every k point is offsetted by offset.\n\nThe integration over ω would have an absolute tolerance atol, with maximal evaluation number being maxevals for each k point.\n\nFor a crystal, since this function does not know the volume of the Brillouin zone, it simply sums over k points and divide the result by the number of k points. The most common situation is calculating the density of ⟨O⟩, in which case the result should be multiplied by the volume of the Brillouin zone and divided by (2π)^3.\n\n\n\n\n\n","category":"function"},{"location":"response/#HopTB.Response.get_Floquet_response","page":"HopTB.Response","title":"HopTB.Response.get_Floquet_response","text":"get_Floquet_response(getH::Function, getO::Function, getV::Function,\n    getn::Function, l::Int64, k::Vector{Float64}; Γ::Float64=0.1,\n    atol::Float64=0.0, maxevals::Int64=typemax(Int64))\n\nCalculate Floquet response at k.\n\nThe response is the linear change of ⟨O⟩ due to V added to the original Hamiltonian. getH, getO and getV all take k as the only argument and output corresponding matrices.\n\nWe here assume operator O and V are time independent, such that their size should be number of orbital. However, H should be Floquet Hamiltonian and should have size (2forder+1)norbits.\n\n⟨O⟩ might be time dependent but periodic. l denotes that the output is the coefficient of ⟨O⟩ before e^{-i l Ω t}.\n\nΓ is the broadening factor. If the every degree of the system is coupled to a wide-band heat bath, Γ=i T^2 ν, where T is the hopping constant between the system and the heat bath and ν is the density of states of the heat bath. The heat bath has a occupation distribution getn(ω).\n\nThe integration over ω would have an absolute tolerance atol, with maximal evaluation number being maxevals.\n\n\n\n\n\nget_Floquet_response(getH::Function, getO::Function, getV::Function,\n    getn::Function, l::Int64, nkmesh::Vector{Int64}; Γ::Float64=0.1,\n    offset::Vector{Float64}=[0.0, 0.0, 0.0], k1::Vector{Float64}=[0.0, 0.0, 0.0],\n    k2::Vector{Float64}=[1.0, 1.0, 1.0], atol::Float64=0.0, maxevals::Int64=typemax(Int64))\n\nCalculate Floquet response.\n\nThe response is the linear change of ⟨O⟩ due to V added to the original Hamiltonian. getH, getO and getV all take k as the only argument and output corresponding matrices.\n\nWe here assume operator O and V are time independent, such that their size should be number of orbital. However, H should be Floquet Hamiltonian and should have size (2forder+1)norbits.\n\n⟨O⟩ might be time dependent but periodic. l denotes that the output is the coefficient of ⟨O⟩ before e^{-i l Ω t}.\n\nΓ is the broadening factor. If the every degree of the system is coupled to a wide-band heat bath, Γ=i T^2 ν, where T is the hopping constant between the system and the heat bath and ν is the density of states of the heat bath. The heat bath has a occupation distribution getn(ω).\n\nThe response function is integrated in a rectangle with corners k1 and k2. The mesh is nkmesh and every k point is offsetted by offset.\n\nThe integration over ω would have an absolute tolerance atol, with maximal evaluation number being maxevals for each k point.\n\nFor a crystal, since this function does not know the volume of the Brillouin zone, it simply sums over k points and divide the result by the number of k points. The most common situation is calculating the density of ⟨O⟩, in which case the result should be multiplied by the volume of the Brillouin zone and divided by (2π)^3.\n\n\n\n\n\n","category":"function"},{"location":"response/#HopTB.Response.clt_Floquet_response","page":"HopTB.Response","title":"HopTB.Response.clt_Floquet_response","text":"clt_Floquet_response(getH::Function, getO::Function, getV::Function,\n    getn::Function, l::Int64, ks::Matrix{Float64}; Γ::Float64=0.1,\n    atol::Float64=0.0, maxevals::Int64=typemax(Int64))\n\nCollect k-resolved Floquet response in ks. ks is in reduced coordinates and stored in columns.\n\nMost options are identical to get_Floquet_response.\n\n\n\n\n\n","category":"function"},{"location":"hall/#HopTB.Hall","page":"Hall effects","title":"HopTB.Hall","text":"","category":"section"},{"location":"hall/","page":"Hall effects","title":"Hall effects","text":"HopTB.Hall.getahc\nHopTB.Hall.getshc\nHopTB.Hall.collect_berry_curvature","category":"page"},{"location":"hall/#HopTB.Hall.getahc","page":"Hall effects","title":"HopTB.Hall.getahc","text":"getahc(atm::AbstractTBModel, α::Int64, β::Int64, nkmesh::Vector{Int64};\n    Ts::Vector{Float64}=[0.0], μs::Vector{Float64}=[0.0])::Matrix{Float64}\n\nCalculate anomalous Hall conductivity σ^αβ.\n\nAnomalous Hall conductivity is defined by\n\nσ^αβ=-frace^2ħintfracdboldsymbolk(2pi)^3f_nΩ_nn^αβ\n\nThe returned matrix σ^αβm n is AHC for temperature Ts[m] and chemical potential μs[n].\n\nThe returned AHC is in unit (Ω⋅cm)^-1.\n\n\n\n\n\n","category":"function"},{"location":"hall/#HopTB.Hall.getshc","page":"Hall effects","title":"HopTB.Hall.getshc","text":"getshc(tm::TBModel, α::Int64, β::Int64, γ::Int64, nkmesh::Vector{Int64};\n    Ts::Vector{Float64}=[0.0], μs::Vector{Float64}=[0.0], ϵ::Float64=0.1)::Matrix{Float64}\n\nCalculate spin Hall conductivity for different temperature (Ts, first dimension) and chemical potential (μs, second dimension).\n\nSpin Hall conductivity is defined as\n\nσ_αβ^γ = eħintfracd^3 boldsymbolk(2π)^3sum_n f_n Ω^γ_nαβ\n\nwhere the spin Berry curvature is\n\nΩ_nαβ^γ = -2 textIm sum_mn fracnhatj_α^γmmhatv_βn(ϵ_n-ϵ_m)^2+ϵ^2\n\nand the spin current operator is\n\nhatj_α^γ = frac12 hatv_a hats_c\n\nSpin Hall conductivity from this function is in ħ/e (Ω*cm)^-1.\n\n\n\n\n\n","category":"function"},{"location":"hall/#HopTB.Hall.collect_berry_curvature","page":"Hall effects","title":"HopTB.Hall.collect_berry_curvature","text":"collect_berry_curvature(atm::AbstractTBModel, α::Int64, β::Int64, kpts::AbstractMatrix{Float64})::Matrix{Float64}\n\nCollect berry curvature.\n\nStandard units is used (eV and Å).\n\nThe returned matrix Ω[n, ik] is berry curvature for band n at ik point.\n\n\n\n\n\n","category":"function"},{"location":"#HopTB.jl","page":"Introduction","title":"HopTB.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"HopTB.jl is a tight-binding package written in julia. The package has the ability of dealing with non-orthogonal tight-binding models and aims at both first principle calculations of real materials and model calculations.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"For real materials, HopTB.jl currently has interfaces with Wannier90, openMX and FHI-aims. Tight-binding systems are created with these density functional packages and HopTB.jl is a post-processing tool.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"For model calculation, HopTB.jl has a similar API as pythtb to construct tight-binding models.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"HopTB.jl provides infrastructure for analyzing response function and analyzing band structures. In addition, HopTB.jl contains out-of-box features including","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Permittivity\nDrude weight\nAnomalous Hall effect\nSpin Hall effect\nShift current conductivity\nSecond harmonic generation\nSymmetrization of tight binding model\nIntrinsic nonlinear Hall conductivity\nBerry curvature dipole\nSecond order Drude weight\nFermi surface extraction","category":"page"}]
}
